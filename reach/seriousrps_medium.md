Reach! I discovered Reach after Reach-ing out to CTO Jay McCarthy, once my professor at Vassar, to forward a blockchain whitepaper with a similar look to Racket, a programming language he contributes to. On that subject, he told me he had begun work on a new blockchain programming language that could automatically and verifiably compile to muliple blockchains. The concept was already incredible, and knowing Jay, I had full confidence that his expertise in formal verification, compilers, and generally insightful approach to computing meant this platform would be a game-changer.

The Reach Bounty Hack was the push I needed to dive into Reach and complete a project - a Serious version of Rock Paper Scissors as presented in the Reach tutorial - one in which moves are submitted in batches to reduce the likely number of tranasctions and transactions costs are, as fairly as possible, split between participants. My further goal, which I had begun in advance of the Bounty Hack, was to develop Reach RPS into a fully functional web app, with a search function & games database.

For my project architecture, I chose to use Vue for my front-end and Amazon Web Services for storing & searching RPS game metadata. I'd of course write my smart contracts using Reach, and interface with the compiled .mjs smart contracts using Reach's JS standard library.

I came into this project with many questions. I had never programmed on any blockchain before, nor had I used AWS; and though I had some Vue experience, this project needed careful state management and navigation, requiring me to learn to integrate Vuex Store and Vue Router.

Mapping out the project's data flow felt daunting - how would I coordinate blockchain state, front-end state & UI, and games database entries? The problem became much simpler once I realized Reach would entirely & automatically provide contract state, so long as I made well-formed event hooks in the "interact" interface the front-end provides to Reach's smart contract backend. From these hooks, I could update the UI and database as needed. Therefore, my job in the front-end was to allow players to attach to backends, communicate contract state (to both the player and database), and provide user input to the backend (game parameters + moves). So long as the front-end is attached to the backend of any contract it needs, the backend will call  front-end interact functions as contract state progresses. 

Cryptocurrency wallet management was simple to set up. Reach's standard library currently provides an interface for Ethereum and just before the Bounty Hack added one for Algorand. To prompt access to accounts listed in Metamask (a browser extension to manage ETH wallets), all I had to do was call the stdlib.getDefaultAccount() function. Because of the recency of Algorand support, as well as the relatively new and ongoing development of Algorand wallet protocols, there were some kinks to work out - Algorand's networks are approaching feature parity to Reach's ALGO smart contracts, so I needed to run and connect to Reach's custom Algorand development network. Once I learned how to use Vue CLI to set up a development server & proxy transaction requests to the development network, and also undo some of my own Dockerish mischief, Algorand contracts ran seamlessly (all in all, a straightforward process, amply helped by Jay & Dan from Reach and Krystof, a Reach Sherpa on the Reach Discord server).

As I developed my architecture, I began to modify Rock Paper Scissors. Reach challenged me in that it is incredibly well-formed, in type, grammar, function and general structure. This is one of its benefits, as it allows the compiler to formally verify programs & preserves abstraction such that it may cleanly accomplish blockchain multiplicity. As a programmer recently immersed in web development and used to my own slippery style of javascript, I had to carefully pore through the precisely written Reach docs, debug piece by piece, and often ask Jay for clarification (which he willingly and thoroughly provided). The compiler gives specific, helpful error messages to guide you along the way, and once there are no errors, watching the compiler generate and prove 700 theorems about your program is extremely satisfying. And then, I had two fully functional smart contracts in Solidity and TEAL (concisely contained in a single .mjs file) to plug into my web app.

When the pieces were ready, the process simply worked.

If I spent more time on this project, which I might, I would want to work on:
- hyper-robust web dev error handling around contract/db synchronization. for example, with another day I would have built a re-submit function in the case that a contract is created but the db is inaccessible (direlict contract handling)
- take a maker's fee from contracts
- wallet address aliasing/friends lists & game invites
- simple AI - functions with Reach programs which, through a simple algorithm / decision tree can play games as stand-in for betters.
- add other games!